# Item 17. 변경 가능성을 최소화하라

> 불변 클래스란?

해당 인스턴스의 내부 값을 수정할 수 없는 클래스

불변 인스턴스에 간직된 정보는 객체가 파괴되는 순간까지 절대 달라지지 않는다.

자바 플랫폼 라이브러리에도 다양한 불변 클래스가 있다.

String, 기본타입의 박싱된 클래스, BigInteger, BigDecimal 등등이 있다.

불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽다!

오류 생길 여지도 적어 안전하다.

### 불변 클래스로 만드는 다섯가지의 규칙

1. 객체의 상태를 변경하는 메소드를 제공하지 않는다.
    1. 흔히 구현하는 setter + @
2. 클래스를 확장할 수 없도록 한다.
    1. 하위 클래스에서 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아줌
    2. 대표적인 방법으로는 클래스를 `final` 로 선언하는것
3. 모든 필드를 final로 선언한다.
    1. 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장한다.
4. 모든 필드를 private로 선언한다.
    1. 16장에서 봤던 것처럼 가변 객체에 클라이언트가 직접 접근해서 수정하는 것을 막아준다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 해야한다.
    1. 가변 객체를 참조하는게 하나라도 있다면 클라이언트에서 그 참조를 못얻게 만들어주어야 한다.
    2. 접근자 메소드가 필드를 그대로 반환해서도 안된다.

기존의 책에서 복소수 예제로 주어졌지만, 좀 더 간략하게 보기위해

Money 객체를 이용했다.

[일반 코드](https://github.com/lsj8367/laboratory/tree/master/effective-java/src/main/java/com/github/lsj8367/item17)

[테스트 코드](https://github.com/lsj8367/laboratory/tree/master/effective-java/src/test/java/com/github/lsj8367/item17)

이러한 기능을 JDK 14이상부터는 [record Class](https://www.baeldung.com/java-record-keyword) 가 있기 때문에

클래스에 선언해주면 위에서 구현했던 보일러 플레이팅 과정의 코드들을 record 키워드 하나만으로 대체가 가능하다.

함수형에 익숙하지 않다면 부자연스러워 보일 수 있겠지만,

불변의 영역 비율이 높아지는 장점을 얻을 수 있다.

# 불변 객체의 장점

### 불변 객체는 단순하다

불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.

모든 생성자가 클래스 불변식을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히 불변으로 남는다.

> 클래스 불변식이란?

버트런드 마이어는 `계약에 의한 설계(Design By Contract)`라는 개념을 제시한다.

소프트웨어의 모듈은 권리와 책임을 문서화하고, 그것을 검증하는 것이 핵심.

예를 들어서 이전에 주어진 돈에서 돈을 만들때 null로 만들거나 음수로 만들어서는 안된다!

그리고 더하거나 뺄때의 인자는 `null` 이거나 음수 값이면 예외를 던지는 것이 권리이다.

생성자에서 들어올 수 없는 값이 있다면 전부 예외를 처리해주면 그 클래스는 조건이 맞아 떨어진다고 보증해줄 수 있는 이런것이 바로 클래스 불변식이다.

**돈은 주어진 돈보다 더 많은 돈을 뺄 수 없다** 라는것을 보장받을 수 있는 클래스 불변식이 생긴다.

가변객체는 임의의 복잡한 상태에 놓일 수 있다.

변경자 메소드가 일으키는 상태 변화들을 문서로 남겨놓지 않는다면 믿고 사용하기 어려울 수 있다.

### 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.

Thread가 동시에 사용해도 훼손되지 않는다.

클래스를 가장 Thread-safe 하게 만드는 방법이 이 불변객체로 만드는 방법이다.

변경하는 값들이 없으니 서로 다른 스레드에 영향을 줄 수 없으니까 안심하고 공유가 가능하다.

불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권장한다.

앞장에서 살펴봤던  `Boolean.valueOf()` 가 될 수있다.

### 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩토리를 제공할 수 있다.

앞장에서 봤던 아이템1의 내용이다.

박싱된 기본 타입 클래스들 전부와 BigInteger 가 여기 속한다.

이러한 정적 팩토리를 사용하게 되면 여러 클라이언트가 인스턴스를 **공유** 하게 되어 **메모리 사용량** 과 **GC** 비용이 줄어든다.

새로운 클래스를 설계시 public 생성자가 아닌 정적 팩토리를 만들어두게 되면, 나중에 클라이언트를 수정하지 않고도 캐시 기능을 덧붙일 수도 있다.

### 방어적 복사도 필요 없다.

불변 객체를 자유롭게 공유한다는 점은 이도 된다는 결론이 난다.

아무리 복사해봐야 원본과 똑같아 복사 자체가 의미 없다. (Collections.unmodifiableList())

[방어적 복사 vs Unmodifiable Collection](https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/)

불변 클래스는 clone이나 복사 생성자를 제공하지 않는게 좋다.

String 클래스의 복사생성자는 되도록 사용하지 말자.

### 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.

BigInteger의 negate 메소드

![negate메소드](https://user-images.githubusercontent.com/74235102/193304567-9c6c9d12-680a-4c9a-b715-28e23914f50b.png)

변경되어야 하는 값 외에 나머지는 그대로 재활용해도 새로 만들어주는 것이기 때문에

데이터를 공유해도 안전하단 뜻 같다.

### 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.

불변 x 불변이면 아무리 복잡해도 불변식은 계속 유지될 것이다.

불변 객체는 Map의 키와 Set 원소로 쓰기 좋다. (hashCode를 재정의한다에서 배웠던 내용)

그래서 불변식이 허물어지는 것들을 생각할 필요가 없다.

### 불변 객체는 그 자체로 실패 원자성을 제공한다.

실패원자성은 어떠한 가변 객체에 대해 값을 처리해준다고 가정하면,

그 값에 대해 유효성 검증을 처리하는 역할을 말한다.

실패 원자성을 성취하기 위한 더 좋은 방법은, 객체를 변경하는 코드 전에 앞서서 실패할 수 있는 코드 부분들이 실행되도록 순서를 조정 하는것이 좋다.

# 불변클래스의 단점

값이 다르다면 반드시 독립된 객체로 만들어야 한다는 것.

값의 가지수가 많다면 이들을 만드는데에 전부 큰 비용을 치러야 한다.

원하는 객체를 완성하기까지의 단계가 많고, 그 중간 단계에서 만들어진 객체들이 모두 버려진다면

성능 문제가 더 불거진다.

### 문제를 대처하는 방법

> 흔히 쓰일 다단계 연산들을 예측하여 기본기능으로 제공

연산 속도를 높이기 위해 가변동반 클래스사용

`String` 의 가변 동반 클래스인 `StringBuilder` 도 안에 `AbstractStringBuilder` 를 package-private로 두고 있다.

마지막에 toString 메소드를 통해 String을 반환해주는 식으로 동작하게 되어있다.

# 불변 클래스를 만드는 또 다른 설계 방법

기존 방식은 클래스를 final로 만드는 것.

더 유연한 방법은 모든 생성자를 private로 만들고, 정적 팩토리를 제공하는 방법이다.

![demo클래스](https://user-images.githubusercontent.com/74235102/193304589-4286e7ae-4279-43b9-9934-4394e6a13bd3.png)

![subdemo클래스](https://user-images.githubusercontent.com/74235102/193304601-e102acaa-ab11-4270-b06a-938d83b53be1.png)

다 막아두면 위 이미지와 같이 상속을 받을 수 없다.

package-private로 구현하게 된다면, 바깥에서는 불변객체지만, 패키지 안에서는 자유롭게 원하는 수준으로 만들 수 있다.

때문에 정적 팩토리 방식은 다수의 구현 클래스를 활용한 유연성을 제공한다.

위에서 봤던 `BigInteger` 나 `BigDecimal` 을 설계 당시에는 불변 객체가 사실상 final이어야 한다는 생각이 널리 퍼지지 않았다고 한다.

그래서 재정의 할 수 있게 설계되어 하위 호환성이 고려된다.

그래서 이 타입의 값들을 받을때에는 주의해서 받아야한다.

> 모든 필드가 final이고 어떤 메소드도 그 객체를 수정할 수 없어야 한다.

**너무 과하다!!!**

> 어떤 메소드도 객체의 상태중 외부에 비춰지는 값을 변경할 수 없다. 

완화된 느낌

어떤 불변 클래스는 계산 비용이 큰 값을 나중에 계산하여 final이 아닌 필드에 캐시를 발라놓기도 한다.

똑같은 값을 다시 요청하면 캐시해둔 값을 반환하여 계산 비용을 절감하는 것이다.

Ex) `ObjectMapper`

### 직렬화 시 추가로 주의할 점

`Serializable` 을 구현하는 불변 클래스 내부에 가변 객체를 참조하는 필드가 있다면,

readObject나 readResolve 메소드를 **반드시** 제공하거나

Object I/O Stream 의 writeUnshared, readUnshared 메소드를 사용해야 한다.

# 정리

getter가 있다고해서 setter를 정의할 필요가 없다. (**무지성 롬복으로 @Getter, @Setter 주의!!** )

> 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

그래서 jdk14에서 record부터 구현시작하는게 그런 이유일까 싶기도 하다.

불변클래스는 장점이 많으며, 단점은 특정 상황에서의 성능저하.

단순 값 객체는 항상 불변으로 만드는 습관을 들이자.

무거운 객체들도 불변으로 만들수 있는지 고려해보고, 성능 때문에 안될 것 같다면

가변 동반 클래스를 사용하여 제공하는것도 방법이다.

## 모든 클래스를 불변으로 만들순 없다.

불변으로 만들 수 없다면 변경할 수 있는 부분을 최소한으로 줄이자.

**꼭 변경해야할 필요가 있는 필드를 제외하고는 모두 final로 선언하자.**

## 핵심요약

- 다른 합당하고 타당한 이유가 없다면 모든 필드는 `private final` 을 붙이자.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
- 확실한 이유가 없다면 생성자와 정적 팩토리 외에는 그 어떤 초기화 메소드도 `public` 으로 제공해선 안된다.
    - 복잡성만 커지고 성능 이점은 거의 없다.