# Item 44. 표준 함수형 인터페이스를 사용해라

자바가 람다를 지원하면서 API를 작성하는 모범사례도 바뀌었다.

상위 클래스의 기본 메소드를 override 하여 원하는 동작을 구현하는 **템플릿 메소드** 패턴의 매력이 크게 줄었다.

이런 방법을 사용하고 싶을 때 같은 효과의 함수 객체를 받는 정적 팩토리나 생성자를 제공하는 것이다.

커스텀한 함수형 인터페이스를

```java
@FunctionalInterface
public interface Foo {
    void bar();
}
```

위와 같이 만들어 줄 수는 있겠으나, 자바 라이브러리에 비슷한 기능을 하는 인터페이스들을 찾아보자.

`java.util.function` 패키지에는 다양한 용도의 표준 함수형 인터페이스가 담겨있다.

> 필요한 용도에 맞는게 있다면, 직접 구현말고 표준 함수형 인터페이스를 활용하자.

표준 함수형 인터페이스들은 유용한 디폴트 메소드를 많이 제공하기에 다른 코드와의 상호 운용성도 좋아진다.

## java.util.function 맛보기

총 43개의 인터페이스가 있고 기본 인터페이스 6개만 기억하게되면 나머지를 충분히 유추해낼 수 있다. 이 기본 인터페이스들은 모두 참조타입용이다.

### 인터페이스 종류

- `Predicate`
    - 인수 한개를 받아 boolean을 반환하는 함수
    - filter에 많이 들어가게 되는 함수
    - `Foo::isEqualTo`
- `Function`
    - 인수와 반환 타입이 다른 함수
    - `Arrays::asList`
- `Supplier`
    - 인수를 받지 않고 값을 반환하는 함수
    - `Foo::getNumber`
- `Consumer`
    - 인수를 하나 받고 반환값은 없는 함수
    - `System.out::println`
    

## 표준 함수형 인터페이스

대부분은 기본 타입만 지원한다.

> 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하진 말자.

동작은 하지만, 계산량이 많다면 형변환을 계속해서 일으키기 때문에 성능이 완전 느려질 수 있다.

### 그렇다면 직접 만들어줄 때는 언제인지?

단순하게 표준 함수형 인터페이스들 중에 없는경우

> Comparator<T>

구조적으로는 ToIntBiFuction<T, U> 와 동일 → 어떤 부분이 동일한지 잘 모르겠음.

Comparator가 독자적 인터페이스로 살아남아야 하는 이유

1. API에서 굉장히 자주 사용되고, 지금 갖고있는 이름이 용도를 아주 잘 설명해준다.
2. 구현하는 쪽에서 반드시 지켜야할 규약을 담고 있다.
3. 비교자들을 변환하고 조합해주는 디폴트 메소드들을 담고있다.

이들 중 하나이상을 만족한다면, 전용 함수형 인터페이스를 고려해야하는 것은 아닌지 고려해야한다.

어디까지나 **인터페이스** 인것을 명심해야 한다.

## @FunctionalInterface

사용하는 이유

- @Override를 사용하는 이유와 비슷.
- 프로그래머의 의도를 명시
- 클라이언트의 입장에서 인터페이스가 람다용으로 설계된 것임을 알려줌.
- 해당 인터페이스가 추상 메소드를 오직 하나만 갖고있어야 컴파일되게 해줌
    - 아예 없을경우, 2개인경우 전부 컴파일에러
- 유지보수 과정에서 누군가 실수로 메소드를 추가하지 못하게 막아준다.

> 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface를 사용하자

## 주의점

- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메소드들을 다중정의해선 안됨.
    - 클라이언트에게 불필요한 모호함 + 모호함으로 인한 문제발생