# Item 76. 가능한 한 실패 원자적으로 만들라

여기서 하는 얘기는 예외가 발생해도 해당하는 객체는 그 호출 전 상태를 유지해야 한다.

요것이 바로 실패 원자적이어야 한다는 것이다.

## 메소드를 실패 원자적으로 만드는 방법

### 불변객체로 설계하자

불변객체는 태생이 실패 원자적이다.

메소드가 실패하게 되면 원하는대로 동작할 수는 없으나, 그 객체 자체가 불안정해지는 일은 없다.

변하는게 없기 때문이다.

### 가변 객체의 메소드를 실패 원자적으로 만드는 방법

매개변수의 유효성을 전부 검사하는 것이다.

```java
public class Wallet {
    private int money; // 편의상 int로 설정, 가변불변 둘다 포함이라 final은 안넣음.
    private final List<Card> cards;
    public Wallet(final int money) {
        this.money = validMoney(money);
        this.cards = new ArrayList<>();
    }

    public Wallet addMoney(final int money) {
        validMoney(money);
        return new Wallet(this.money + money);
    }

    public void addMoney(final int money) {
        validMoney(money);
        this.money += money;
    }
    
    private void validMoney(final int money) {
        if (money < 0) {
            throw new IllegalArgumentException("돈이 음수값 일 수 없습니다.");
        }
    }
}
```

### 실패할 가능성이 있다면 최전방에 배치하자

계산이 들어가는 로직보다 무조건적으로 앞에 배치하게 되면, 계산과정에서 예외가 나지 않을 것이다.

> 개인적 의견이지만, 여기에 테스트 코드를 넣는게 가장 바람직 할것 같다.

되는 상황부터가 아닌 예외 상황부터 정의하면 코드가 단순해지는걸 많이 느꼈음.

### 임시 복사본에서 작업을 수행 후 원래 객체와 교체

데이터를 임시 자료구조에 저장해 작업하는게 더 빠른경우 적용.

ex ) 리스트에 정렬이 필요하면, 정렬에선 배열이 훨씬 좋기에 배열로 복사해서 값을 정렬하는 경우 리스트에는 변화가 없다는 것.

### 작업도중 발생하는 실패를 가로채는 복구코드 작성

별도의 temp 변수들에 저장해두고 catch시 되돌리는 방법을 생각했다.

근데 책에서 설명하길 `디스크 기반의 내구성을 보장해야 하는 자료구조` 라고 나오기에 DB의 트랜잭션을 생각했다.

## 동시성에서의 실패 원자성

실패 원자성은 권장되지만 동시성에선 실패 원자성이 보장되지 못한다.

그래서 동시성의 예외인 `Concurrent` 종류의 예외를 만나도 제대로 잡았다고 보장할 수 없다.

## 무조건 실패 원자적으로 만들어야 하는 것은 아니다.

실패 원자성만을 위해 달리면 이를 위한 비용이나 복잡도가 아주 큰 연산도 존재한다.

그래도 원초적으로 문제가 무엇인지를 파악한다면 실패 원자성은 공짜로 얻을 수 있게된다.

메소드 명세에 기술했다면 예외가 발생해도 메소드 호출 전과 같은 상태로 있어야한다.

이 규칙을 지키지 못한다면 실패한 경우의 객체 상태를 자바독에 명시해주자.
