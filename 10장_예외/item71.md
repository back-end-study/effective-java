# 아이템 71. 필요 없는 검사 예외 사용은 피하라


검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이 게끔 해준다. <br><br>
물론, 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된 다.
어떤 메서드가 검사 예외를 던질 수 있다고 선언됐다면,
이를 호출하는 코 드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다.
어느 쪽이든 API 사용자에게 부담을 준다.<br><br>
더구나 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에(아이템 45-48) 자바 8부터는 부담이 더욱 커졌다.

검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외 만 던질 때가 특히 크다. 이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 경우라면 기껏해야 catch 문 하나 추가하는 선에서 끝이다.
하지만 검사 예외가 단 하나뿐이라면 오직 그 예외 때문에 API 사용자는 try 블록을 추가해야 하고 스트림에서 직접 사용하지 못하게 된다.<br><br>
그러니 이런 상 황이라면 검사 예외를 안 던지는 방법이 없는지 고민해볼 가치가 있다.<br>

검사 예외를 회피하는 가장 쉬운 방법
1. 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다(아이템 55). 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다.<br>
단점: 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.<br>
-> 예외를 사용하면 구체적인 예외 타입과 그 타 입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다(아이템 70).
2. 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다. 이 방식에서 첫 번째 메서드는 예외가 던져질지 여부를 boolean 값으로 반환한다. 다음의 예를 보자.

리팩터링 전
```java
try {
    obj.action(args);
} catch (TheCheckedException e) {
... // 예외 상황에 대처한다.
}
```
리팩터링 후
```java
if (obj.actionPermitted(args)) {
    obj.action(args);
} else {
...
}
```
이 리팩터링을 모든 상황에 적용할 수도 없고, 리팩터링 후가 딱히 더 아름답지도 않다. 하지만 더 유연하다.<br>
프로그래머가 이 메서드가 성공하리라는 걸 안다거나, 실패 시 스레드를 중단하길 원한다면 다음처럼 한 줄로 작성해도 무방하다.<br>
이 한 줄짜리 호출 방식 이 주로 쓰일 거로 판단되면 리팩터 링하는 편이 바람직 하다. <br>
한편, actionPermitted는 상태 검사 메서드에 해당하므로 아이템 69에서 말한 단점도 그대로 적용되니 주의해야 한다.<br>
즉, 외부 동기화 없이 여러 스레 드가 동시에 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 이 리 팩터링은 적절하지 않다.<br>
actionPemitted와 action 호출 사이에 객체의 상태 가 변할 수 있기 때문이다.<br>
또한 actionPemitted가 action 메서드의 작업 일부 를 중복 수행한다면 성능에서 손해이니, 역시 이 리팩터링이 적절하지 않을 수 있다.<br>


### 정리<br>
꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성올 높여주지만, 남용하면 더 쓰기 고통스러운 API를 낳는다.
API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. <br>
복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없올 때만 검사 예외를 던지자
